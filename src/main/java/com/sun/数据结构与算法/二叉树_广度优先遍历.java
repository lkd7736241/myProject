package com.sun.数据结构与算法;

import com.sun.vo.TreeNode;

/**
 * 1. 利用队列，先将根节点放入队列
 * 2. 从队列中移出一个元素，如果该元素有子节点，则将子节点加入队列
 * <p>
 * create by qiulisun on 2021/1/3.<br>
 *
 * @author 51050
 */
public class 二叉树_广度优先遍历 {
    public static void main(String[] args) {
//        TreeNode root = new TreeNode("A");
//        TreeNode b = new TreeNode("B");
//        TreeNode c = new TreeNode("C");
//        TreeNode d = new TreeNode("D");
//        TreeNode e = new TreeNode("E");
//        TreeNode f = new TreeNode("F");
//        TreeNode g = new TreeNode("G");
//        root.setLeft(b);
//        root.setRight(c);
//        b.setLeft(d);
//        b.setRight(e);
//        c.setLeft(f);
//        c.setRight(g);
//
//        breadthFirstSearch(root);
    }

    public static void breadthFirstSearch(TreeNode root) {
//        if (root == null) {
//            System.out.println("the tree is empty");
//            return;
//        }
//        ArrayDeque<TreeNode> queue = new ArrayDeque<>();
//        queue.add(root);
//
//        while (!queue.isEmpty()) {
//            TreeNode node = queue.remove();
//            System.out.println(node.getVal());
//            if (node.getLeft() != null) {
//                queue.add(node.getLeft());
//            }
//            if (node.getRight() != null) {
//                queue.add(node.getRight());
//            }
//        }
    }
}